// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

model User {
  id                     String                    @id @default(cuid())
  clerkId                 String?                 @unique 
  gender              Gender?
  isAdmin             Boolean                @default(false)
  firstName           String?
  lastName            String?
  nameOtherLang       String?
  careerGoal          String?
  careerGoalEng       String?
  graduationYear      Int?
  email               String?                @unique
  wechatId            String?
  interests           String?
  interestsEng        String?
  hometown            String?
  hometownEng         String?
  linkedInLink        String?
  instagramLink       String?
  twitterLink         String?
  xiaohongshuID       String?
  major               String?
  majorEng            String?
  school              String?
  profilePictureURL   String?
  phone              String?
  bio                 String?
  botSummary          String?                @default("")
  joinedDate          DateTime?
  currentCity         String?
  isOnboarded         Boolean                @default(false)
  personalTags        String[]
  professionalTags    String[]
  currentCompany      String?
  currentRole         String?
  savedBy             UserSave[]             @relation("saved by")
  saves               UserSave[]             @relation("saves")
  createdAt           DateTime                @default(now())
  updatedAt           DateTime                @updatedAt
  deletedAt              DateTime?                // Indicates soft-deleted records

  isMentor            Boolean                @default(false)
  mentorProfile       MentorProfile?
  menteeProfile       MenteeProfile?
  @@map("users")
}


model UserSave {
  id        Int      @id @default(autoincrement())
  saveInitiatorUserId    String
  saveReceiverUserId String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt @default(now())
  saveInitiatorUser      User     @relation("saves", fields: [saveInitiatorUserId], references: [id], onDelete: Cascade)
  saveReceiverUser User     @relation("saved by", fields: [saveReceiverUserId], references: [id], onDelete: Cascade)

  @@map("user_saves")
  @@index([saveInitiatorUserId], name: "idx_save_initiator")
  @@index([saveReceiverUserId], name: "idx_save_receiver")

}


model ExpertiseArea {
  id    Int      @id @default(autoincrement())
  name  String   @unique // Example: "Data Science", "Marketing", "Leadership"
  mentors MentorProfile[] @relation("MentorExpertise") // Define opposite side of the relation

  @@map("expertise_areas")
}


model MentorProfile {
  id                   String      @id @default(cuid())
  userId               String      @unique // Ensure a mentor has one profile
  user                 User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  // Mentor-specific fields
  bio                  String?     // A bio specifically as a mentor
  yearsOfExperience    Int?
  pastExperience       String?     // Description of past experience (free-form text or JSON)
  
  
  // Mentee expectation
  menteeExpectations   String?     // Free-form text to explain what mentors expect from mentees
  menteeQualifications String[]    // Specific qualifications or skills mentors want from mentees

    // Mentorship logistics
  maxMentees           Int?        // Max number of mentees a mentor can have
  availability         String?     // Mentors can specify available times or schedules
  
  expertiseAreas       ExpertiseArea[] @relation("MentorExpertise")
  applications         Application[]   @relation("applicationsReceivedAsMentor")
  mentorship           Mentorship[]   @relation("mentorshipsAsMentor")

  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  @@map("mentor_profiles")
}


model MenteeProfile {
  id                  String          @id @default(cuid())
  userId              String          @unique
  user                User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  bio                 String?
  careerGoals         String?
  currentChallenges   String?

  mentorPreferences   String?         // Expectations or preferences for the mentor
  availability        String?         // Availability of the mentee for meetings

  applications         Application[]   @relation("applicationsSentAsMentee")
  mentorship           Mentorship[]   @relation("mentorshipsAsMentee")
  createdAt           DateTime        @default(now())
  updatedAt           DateTime        @updatedAt

  @@map("mentee_profiles")
}


model Mentorship {
  id                   String     @id @default(cuid())
  
  menteeId             String
  mentee               MenteeProfile       @relation("mentorshipsAsMentee", fields: [menteeId], references: [id], onDelete: Cascade)
  
  mentorId             String
  mentor               MentorProfile @relation("mentorshipsAsMentor", fields: [mentorId], references: [id], onDelete: Cascade)
  
  startDate            DateTime    @default(now())
  endDate              DateTime?   // Could be null if the mentorship is ongoing
  
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  @@map("mentorships")
}


model Application {
  id                   String     @id @default(cuid())
  menteeId             String
  mentee               MenteeProfile       @relation("applicationsSentAsMentee", fields: [menteeId], references: [id], onDelete: Cascade)
  
  mentorId             String
  mentor               MentorProfile @relation("applicationsReceivedAsMentor", fields: [mentorId], references: [id], onDelete: Cascade)
  
  status               ApplicationStatus  // Enum: PENDING, ACCEPTED, REJECTED
  appliedAt            DateTime           @default(now())
  responseAt           DateTime?
  message              String?            // Optional message from mentee
  
  @@map("applications")
}

enum ApplicationStatus {
  PENDING
  ACCEPTED
  REJECTED
}
